// Code generated by SQLBoiler 3.6.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Applicant is an object representing the database table.
type Applicant struct {
	ID                 string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	ApplicationStateID string            `boil:"application_state_id" json:"application_state_id" toml:"application_state_id" yaml:"application_state_id"`
	Name               string            `boil:"name" json:"name" toml:"name" yaml:"name"`
	Email              string            `boil:"email" json:"email" toml:"email" yaml:"email"`
	JobCategory        null.String       `boil:"job_category" json:"job_category,omitempty" toml:"job_category" yaml:"job_category,omitempty"`
	PreviousProjects   null.String       `boil:"previous_projects" json:"previous_projects,omitempty" toml:"previous_projects" yaml:"previous_projects,omitempty"`
	StartDate          time.Time         `boil:"start_date" json:"start_date" toml:"start_date" yaml:"start_date"`
	WorkHours          float32           `boil:"work_hours" json:"work_hours" toml:"work_hours" yaml:"work_hours"`
	Salary             float32           `boil:"salary" json:"salary" toml:"salary" yaml:"salary"`
	Device             string            `boil:"device" json:"device" toml:"device" yaml:"device"`
	Discovery          string            `boil:"discovery" json:"discovery" toml:"discovery" yaml:"discovery"`
	ResumeURL          string            `boil:"resume_url" json:"resume_url" toml:"resume_url" yaml:"resume_url"`
	OptionalFiles      types.StringArray `boil:"optional_files" json:"optional_files,omitempty" toml:"optional_files" yaml:"optional_files,omitempty"`
	GDPRAccepted       bool              `boil:"gdpr_accepted" json:"gdpr_accepted" toml:"gdpr_accepted" yaml:"gdpr_accepted"`
	LastChange         time.Time         `boil:"last_change" json:"last_change" toml:"last_change" yaml:"last_change"`
	Seniority          null.String       `boil:"seniority" json:"seniority,omitempty" toml:"seniority" yaml:"seniority,omitempty"`
	FirstInterview     null.Time         `boil:"first_interview" json:"first_interview,omitempty" toml:"first_interview" yaml:"first_interview,omitempty"`
	SecondInterview    null.Time         `boil:"second_interview" json:"second_interview,omitempty" toml:"second_interview" yaml:"second_interview,omitempty"`
	Notes              null.String       `boil:"notes" json:"notes,omitempty" toml:"notes" yaml:"notes,omitempty"`
	CreatedAt          time.Time         `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt          time.Time         `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *applicantR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L applicantL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ApplicantColumns = struct {
	ID                 string
	ApplicationStateID string
	Name               string
	Email              string
	JobCategory        string
	PreviousProjects   string
	StartDate          string
	WorkHours          string
	Salary             string
	Device             string
	Discovery          string
	ResumeURL          string
	OptionalFiles      string
	GDPRAccepted       string
	LastChange         string
	Seniority          string
	FirstInterview     string
	SecondInterview    string
	Notes              string
	CreatedAt          string
	UpdatedAt          string
}{
	ID:                 "id",
	ApplicationStateID: "application_state_id",
	Name:               "name",
	Email:              "email",
	JobCategory:        "job_category",
	PreviousProjects:   "previous_projects",
	StartDate:          "start_date",
	WorkHours:          "work_hours",
	Salary:             "salary",
	Device:             "device",
	Discovery:          "discovery",
	ResumeURL:          "resume_url",
	OptionalFiles:      "optional_files",
	GDPRAccepted:       "gdpr_accepted",
	LastChange:         "last_change",
	Seniority:          "seniority",
	FirstInterview:     "first_interview",
	SecondInterview:    "second_interview",
	Notes:              "notes",
	CreatedAt:          "created_at",
	UpdatedAt:          "updated_at",
}

// Generated where

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperfloat32 struct{ field string }

func (w whereHelperfloat32) EQ(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperfloat32) NEQ(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperfloat32) LT(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperfloat32) LTE(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperfloat32) GT(x float32) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperfloat32) GTE(x float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperfloat32) IN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var ApplicantWhere = struct {
	ID                 whereHelperstring
	ApplicationStateID whereHelperstring
	Name               whereHelperstring
	Email              whereHelperstring
	JobCategory        whereHelpernull_String
	PreviousProjects   whereHelpernull_String
	StartDate          whereHelpertime_Time
	WorkHours          whereHelperfloat32
	Salary             whereHelperfloat32
	Device             whereHelperstring
	Discovery          whereHelperstring
	ResumeURL          whereHelperstring
	OptionalFiles      whereHelpertypes_StringArray
	GDPRAccepted       whereHelperbool
	LastChange         whereHelpertime_Time
	Seniority          whereHelpernull_String
	FirstInterview     whereHelpernull_Time
	SecondInterview    whereHelpernull_Time
	Notes              whereHelpernull_String
	CreatedAt          whereHelpertime_Time
	UpdatedAt          whereHelpertime_Time
}{
	ID:                 whereHelperstring{field: "\"applicants\".\"id\""},
	ApplicationStateID: whereHelperstring{field: "\"applicants\".\"application_state_id\""},
	Name:               whereHelperstring{field: "\"applicants\".\"name\""},
	Email:              whereHelperstring{field: "\"applicants\".\"email\""},
	JobCategory:        whereHelpernull_String{field: "\"applicants\".\"job_category\""},
	PreviousProjects:   whereHelpernull_String{field: "\"applicants\".\"previous_projects\""},
	StartDate:          whereHelpertime_Time{field: "\"applicants\".\"start_date\""},
	WorkHours:          whereHelperfloat32{field: "\"applicants\".\"work_hours\""},
	Salary:             whereHelperfloat32{field: "\"applicants\".\"salary\""},
	Device:             whereHelperstring{field: "\"applicants\".\"device\""},
	Discovery:          whereHelperstring{field: "\"applicants\".\"discovery\""},
	ResumeURL:          whereHelperstring{field: "\"applicants\".\"resume_url\""},
	OptionalFiles:      whereHelpertypes_StringArray{field: "\"applicants\".\"optional_files\""},
	GDPRAccepted:       whereHelperbool{field: "\"applicants\".\"gdpr_accepted\""},
	LastChange:         whereHelpertime_Time{field: "\"applicants\".\"last_change\""},
	Seniority:          whereHelpernull_String{field: "\"applicants\".\"seniority\""},
	FirstInterview:     whereHelpernull_Time{field: "\"applicants\".\"first_interview\""},
	SecondInterview:    whereHelpernull_Time{field: "\"applicants\".\"second_interview\""},
	Notes:              whereHelpernull_String{field: "\"applicants\".\"notes\""},
	CreatedAt:          whereHelpertime_Time{field: "\"applicants\".\"created_at\""},
	UpdatedAt:          whereHelpertime_Time{field: "\"applicants\".\"updated_at\""},
}

// ApplicantRels is where relationship names are stored.
var ApplicantRels = struct {
	ApplicationState            string
	ApplicantTags               string
	ApplicationStateTransitions string
}{
	ApplicationState:            "ApplicationState",
	ApplicantTags:               "ApplicantTags",
	ApplicationStateTransitions: "ApplicationStateTransitions",
}

// applicantR is where relationships are stored.
type applicantR struct {
	ApplicationState            *ApplicationState
	ApplicantTags               ApplicantTagSlice
	ApplicationStateTransitions ApplicationStateTransitionSlice
}

// NewStruct creates a new relationship struct
func (*applicantR) NewStruct() *applicantR {
	return &applicantR{}
}

// applicantL is where Load methods for each relationship are stored.
type applicantL struct{}

var (
	applicantAllColumns            = []string{"id", "application_state_id", "name", "email", "job_category", "previous_projects", "start_date", "work_hours", "salary", "device", "discovery", "resume_url", "optional_files", "gdpr_accepted", "last_change", "seniority", "first_interview", "second_interview", "notes", "created_at", "updated_at"}
	applicantColumnsWithoutDefault = []string{"application_state_id", "name", "email", "job_category", "previous_projects", "start_date", "work_hours", "salary", "device", "discovery", "resume_url", "optional_files", "gdpr_accepted", "last_change", "seniority", "first_interview", "second_interview", "notes", "created_at", "updated_at"}
	applicantColumnsWithDefault    = []string{"id"}
	applicantPrimaryKeyColumns     = []string{"id"}
)

type (
	// ApplicantSlice is an alias for a slice of pointers to Applicant.
	// This should generally be used opposed to []Applicant.
	ApplicantSlice []*Applicant

	applicantQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	applicantType                 = reflect.TypeOf(&Applicant{})
	applicantMapping              = queries.MakeStructMapping(applicantType)
	applicantPrimaryKeyMapping, _ = queries.BindMapping(applicantType, applicantMapping, applicantPrimaryKeyColumns)
	applicantInsertCacheMut       sync.RWMutex
	applicantInsertCache          = make(map[string]insertCache)
	applicantUpdateCacheMut       sync.RWMutex
	applicantUpdateCache          = make(map[string]updateCache)
	applicantUpsertCacheMut       sync.RWMutex
	applicantUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single applicant record from the query.
func (q applicantQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Applicant, error) {
	o := &Applicant{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for applicants")
	}

	return o, nil
}

// All returns all Applicant records from the query.
func (q applicantQuery) All(ctx context.Context, exec boil.ContextExecutor) (ApplicantSlice, error) {
	var o []*Applicant

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Applicant slice")
	}

	return o, nil
}

// Count returns the count of all Applicant records in the query.
func (q applicantQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count applicants rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q applicantQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if applicants exists")
	}

	return count > 0, nil
}

// ApplicationState pointed to by the foreign key.
func (o *Applicant) ApplicationState(mods ...qm.QueryMod) applicationStateQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ApplicationStateID),
	}

	queryMods = append(queryMods, mods...)

	query := ApplicationStates(queryMods...)
	queries.SetFrom(query.Query, "\"application_states\"")

	return query
}

// ApplicantTags retrieves all the applicant_tag's ApplicantTags with an executor.
func (o *Applicant) ApplicantTags(mods ...qm.QueryMod) applicantTagQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"applicant_tags\".\"applicant_id\"=?", o.ID),
	)

	query := ApplicantTags(queryMods...)
	queries.SetFrom(query.Query, "\"applicant_tags\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"applicant_tags\".*"})
	}

	return query
}

// ApplicationStateTransitions retrieves all the application_state_transition's ApplicationStateTransitions with an executor.
func (o *Applicant) ApplicationStateTransitions(mods ...qm.QueryMod) applicationStateTransitionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"application_state_transitions\".\"applicant_id\"=?", o.ID),
	)

	query := ApplicationStateTransitions(queryMods...)
	queries.SetFrom(query.Query, "\"application_state_transitions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"application_state_transitions\".*"})
	}

	return query
}

// LoadApplicationState allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (applicantL) LoadApplicationState(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApplicant interface{}, mods queries.Applicator) error {
	var slice []*Applicant
	var object *Applicant

	if singular {
		object = maybeApplicant.(*Applicant)
	} else {
		slice = *maybeApplicant.(*[]*Applicant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &applicantR{}
		}
		args = append(args, object.ApplicationStateID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &applicantR{}
			}

			for _, a := range args {
				if a == obj.ApplicationStateID {
					continue Outer
				}
			}

			args = append(args, obj.ApplicationStateID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`application_states`), qm.WhereIn(`application_states.id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ApplicationState")
	}

	var resultSlice []*ApplicationState
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ApplicationState")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for application_states")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for application_states")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ApplicationState = foreign
		if foreign.R == nil {
			foreign.R = &applicationStateR{}
		}
		foreign.R.Applicants = append(foreign.R.Applicants, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ApplicationStateID == foreign.ID {
				local.R.ApplicationState = foreign
				if foreign.R == nil {
					foreign.R = &applicationStateR{}
				}
				foreign.R.Applicants = append(foreign.R.Applicants, local)
				break
			}
		}
	}

	return nil
}

// LoadApplicantTags allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (applicantL) LoadApplicantTags(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApplicant interface{}, mods queries.Applicator) error {
	var slice []*Applicant
	var object *Applicant

	if singular {
		object = maybeApplicant.(*Applicant)
	} else {
		slice = *maybeApplicant.(*[]*Applicant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &applicantR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &applicantR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`applicant_tags`), qm.WhereIn(`applicant_tags.applicant_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load applicant_tags")
	}

	var resultSlice []*ApplicantTag
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice applicant_tags")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on applicant_tags")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for applicant_tags")
	}

	if singular {
		object.R.ApplicantTags = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &applicantTagR{}
			}
			foreign.R.Applicant = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ApplicantID {
				local.R.ApplicantTags = append(local.R.ApplicantTags, foreign)
				if foreign.R == nil {
					foreign.R = &applicantTagR{}
				}
				foreign.R.Applicant = local
				break
			}
		}
	}

	return nil
}

// LoadApplicationStateTransitions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (applicantL) LoadApplicationStateTransitions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeApplicant interface{}, mods queries.Applicator) error {
	var slice []*Applicant
	var object *Applicant

	if singular {
		object = maybeApplicant.(*Applicant)
	} else {
		slice = *maybeApplicant.(*[]*Applicant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &applicantR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &applicantR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`application_state_transitions`), qm.WhereIn(`application_state_transitions.applicant_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load application_state_transitions")
	}

	var resultSlice []*ApplicationStateTransition
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice application_state_transitions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on application_state_transitions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for application_state_transitions")
	}

	if singular {
		object.R.ApplicationStateTransitions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &applicationStateTransitionR{}
			}
			foreign.R.Applicant = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ApplicantID {
				local.R.ApplicationStateTransitions = append(local.R.ApplicationStateTransitions, foreign)
				if foreign.R == nil {
					foreign.R = &applicationStateTransitionR{}
				}
				foreign.R.Applicant = local
				break
			}
		}
	}

	return nil
}

// SetApplicationState of the applicant to the related item.
// Sets o.R.ApplicationState to related.
// Adds o to related.R.Applicants.
func (o *Applicant) SetApplicationState(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ApplicationState) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"applicants\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"application_state_id"}),
		strmangle.WhereClause("\"", "\"", 2, applicantPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ApplicationStateID = related.ID
	if o.R == nil {
		o.R = &applicantR{
			ApplicationState: related,
		}
	} else {
		o.R.ApplicationState = related
	}

	if related.R == nil {
		related.R = &applicationStateR{
			Applicants: ApplicantSlice{o},
		}
	} else {
		related.R.Applicants = append(related.R.Applicants, o)
	}

	return nil
}

// AddApplicantTags adds the given related objects to the existing relationships
// of the applicant, optionally inserting them as new records.
// Appends related to o.R.ApplicantTags.
// Sets related.R.Applicant appropriately.
func (o *Applicant) AddApplicantTags(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ApplicantTag) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ApplicantID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"applicant_tags\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"applicant_id"}),
				strmangle.WhereClause("\"", "\"", 2, applicantTagPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ApplicantID, rel.TagID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ApplicantID = o.ID
		}
	}

	if o.R == nil {
		o.R = &applicantR{
			ApplicantTags: related,
		}
	} else {
		o.R.ApplicantTags = append(o.R.ApplicantTags, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &applicantTagR{
				Applicant: o,
			}
		} else {
			rel.R.Applicant = o
		}
	}
	return nil
}

// AddApplicationStateTransitions adds the given related objects to the existing relationships
// of the applicant, optionally inserting them as new records.
// Appends related to o.R.ApplicationStateTransitions.
// Sets related.R.Applicant appropriately.
func (o *Applicant) AddApplicationStateTransitions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ApplicationStateTransition) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ApplicantID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"application_state_transitions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"applicant_id"}),
				strmangle.WhereClause("\"", "\"", 2, applicationStateTransitionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ApplicantID, rel.FromApplicationStateID, rel.ToApplicationStateID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ApplicantID = o.ID
		}
	}

	if o.R == nil {
		o.R = &applicantR{
			ApplicationStateTransitions: related,
		}
	} else {
		o.R.ApplicationStateTransitions = append(o.R.ApplicationStateTransitions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &applicationStateTransitionR{
				Applicant: o,
			}
		} else {
			rel.R.Applicant = o
		}
	}
	return nil
}

// Applicants retrieves all the records using an executor.
func Applicants(mods ...qm.QueryMod) applicantQuery {
	mods = append(mods, qm.From("\"applicants\""))
	return applicantQuery{NewQuery(mods...)}
}

// FindApplicant retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindApplicant(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Applicant, error) {
	applicantObj := &Applicant{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"applicants\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, applicantObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from applicants")
	}

	return applicantObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Applicant) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no applicants provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(applicantColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	applicantInsertCacheMut.RLock()
	cache, cached := applicantInsertCache[key]
	applicantInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			applicantAllColumns,
			applicantColumnsWithDefault,
			applicantColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(applicantType, applicantMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(applicantType, applicantMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"applicants\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"applicants\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into applicants")
	}

	if !cached {
		applicantInsertCacheMut.Lock()
		applicantInsertCache[key] = cache
		applicantInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Applicant.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Applicant) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	key := makeCacheKey(columns, nil)
	applicantUpdateCacheMut.RLock()
	cache, cached := applicantUpdateCache[key]
	applicantUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			applicantAllColumns,
			applicantPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update applicants, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"applicants\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, applicantPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(applicantType, applicantMapping, append(wl, applicantPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update applicants row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for applicants")
	}

	if !cached {
		applicantUpdateCacheMut.Lock()
		applicantUpdateCache[key] = cache
		applicantUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q applicantQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for applicants")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for applicants")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ApplicantSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), applicantPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"applicants\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, applicantPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in applicant slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all applicant")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Applicant) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no applicants provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(applicantColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	applicantUpsertCacheMut.RLock()
	cache, cached := applicantUpsertCache[key]
	applicantUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			applicantAllColumns,
			applicantColumnsWithDefault,
			applicantColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			applicantAllColumns,
			applicantPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert applicants, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(applicantPrimaryKeyColumns))
			copy(conflict, applicantPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"applicants\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(applicantType, applicantMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(applicantType, applicantMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert applicants")
	}

	if !cached {
		applicantUpsertCacheMut.Lock()
		applicantUpsertCache[key] = cache
		applicantUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Applicant record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Applicant) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Applicant provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), applicantPrimaryKeyMapping)
	sql := "DELETE FROM \"applicants\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from applicants")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for applicants")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q applicantQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no applicantQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from applicants")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for applicants")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ApplicantSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), applicantPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"applicants\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, applicantPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from applicant slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for applicants")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Applicant) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindApplicant(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ApplicantSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ApplicantSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), applicantPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"applicants\".* FROM \"applicants\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, applicantPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ApplicantSlice")
	}

	*o = slice

	return nil
}

// ApplicantExists checks if the Applicant row exists.
func ApplicantExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"applicants\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if applicants exists")
	}

	return exists, nil
}
