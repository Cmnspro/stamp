// +build ignore

// This program generates handlers.go. It can be invoked by running
// go generate
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
)

// https://blog.carlmjohnson.net/post/2016-11-27-how-to-use-go-generate/

var (
	// TODO: env: how to get to the project root?
	projectRoot           = "/app"
	handlersRoot          = "/api/handlers/"
	handlersGeneratedFile = "handlers.go"
	// TODO: auto-get project base package
	handlersBasePkg = "allaboutapps.at/aw/go-mranftl-sample/api/handlers/"

	// TODO: also check fn signature
	methodPrefixes = []string{
		"Get", "Head", "Patch", "Post", "Put", "Delete",
	}
	methodSuffix = "Route"

	packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by scripts/handlers_gen.go
package handlers

import (
	"allaboutapps.at/aw/go-mranftl-sample/api"
	{{- range .SubPkgs }}
	"{{ $.BasePkg }}{{ . }}"
	{{- end }}
)

func AttachAllRoutes(s *api.Server) {
	// attach our routes
	{{- range .Funcs }}
	{{ .PackageName }}.{{ .FunctionName }}(s)
	{{- end }}
}
`))
)

type ResolvedFunction struct {
	PackageName  string
	FunctionName string
}

// get all functions in above handler packages
// that match Get*, Put*, Post*, Patch*, Delete*
func main() {

	subPkgs := []string{}

	files, err := ioutil.ReadDir(projectRoot + handlersRoot)
	if err != nil {
		log.Fatal(err)
	}

	for _, f := range files {
		// fmt.Println(f.Name())

		if f.IsDir() {
			subPkgs = append(subPkgs, f.Name())
		}
	}

	funcs := []ResolvedFunction{}

	for _, subPackageName := range subPkgs {

		set := token.NewFileSet()
		packs, err := parser.ParseDir(set, projectRoot+handlersRoot+subPackageName, nil, 0)

		if err != nil {
			fmt.Println("Failed to parse package:", err)
			os.Exit(1)
		}

		for _, pack := range packs {
			for _, f := range pack.Files {
				for _, d := range f.Decls {
					if fn, isFn := d.(*ast.FuncDecl); isFn {

						fnName := fn.Name.String()

						for _, prefix := range methodPrefixes {
							if strings.HasPrefix(fnName, prefix) && strings.HasSuffix(fnName, methodSuffix) {
								funcs = append(funcs, ResolvedFunction{
									FunctionName: fnName,
									PackageName:  subPackageName,
								})
							}
						}
					}
				}
			}
		}

		// print out
		// for _, function := range funcs {
		// 	fmt.Println(function.PackageName, function.FunctionName)
		// }
	}

	f, err := os.Create(projectRoot + handlersRoot + handlersGeneratedFile)

	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	packageTemplate.Execute(f, struct {
		BasePkg string
		SubPkgs []string
		Funcs   []ResolvedFunction
	}{
		BasePkg: handlersBasePkg,
		SubPkgs: subPkgs,
		Funcs:   funcs,
	})

}
